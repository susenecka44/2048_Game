
# 2048 Game Implementation Using Pygame

This documentation covers the 2048 game implementation using the Pygame library, written by Julie Vondráčková for the Programming in Python course at Charles University on May 28, 2024.

## Game Description

- **Modes**:
  - **Classic Mode**: Play without a time limit.
  - **Timed Mode**: You have a 3-minute time limit to achieve the highest score possible.

- **Features**:
  - Ability to undo the last move, with a cooldown of 10 moves.
  - Ability to return to the main menu at any time.
  - Maintains a high score for both game modes.
  - Includes a tutorial screen explaining the rules.

## Dependencies

To run this game, ensure that you have the Pygame library installed. You can install it using pip:

```bash
pip install pygame
```

## Game Components

### Variables

- Window dimensions and screen setup.
- Definitions for game timers and score tracking.
- Colors and fonts for game aesthetics.
- Data structures for storing board values and game state.

### Main Functions

- `draw_board()`: Handles the visual representation of the game board.
- `draw_pieces()`: Draws the tiles on the board based on their values.
- `spawn_piece()`: Adds a new tile to the board in a random position.
- `move_board()`: Updates the board state based on player input.
- `main_menu()`: Displays the main menu and handles mode selection.

### Game Mechanics

- **Undo Function**: Allows the player to revert to the previous board state. Cooldown applied after each use.
- **Game Over Conditions**: Checks if there are no more valid moves left.
- **Score Handling**: Manages and updates the score throughout the game.

### Utility Functions

- `reset_game_data()`: Resets all game-related variables for a new game session.
- `handle_game_events()`: Processes events like mouse clicks and key presses during gameplay.

## Running the Game

To run the game, execute the script in an environment where Pygame is installed. The main game loop is initiated if the script is run as the main module:

```python
if __name__ == "__main__":
    main()
```

The game window will open, and you can select between Classic or Timed mode from the main menu.

## Conclusion

This 2048 game implementation provides an interactive way to understand game development with Pygame, focusing on handling user input, rendering graphics, and implementing game logic.

## Author

**Julie Vondráčková**
- *Date*: 2024-05-28
- *Location*: Charles University, Faculty of Mathematics and Physics


```
documentation generated by pydoc ( More technical ):

FUNCTIONS
    can_move_check(board)
        Check if the board can be moved in any direction (up, down, left, right) by checking if there are any same adjacent
        For determining if the game is over
        Args:
            board: list -> values of the board
        Return:
            bool -> True if the board can be moved in any direction, False otherwise

    classic_game_loop()
        Main game loop for the classic mode

    draw_board(game_type='classic')
        Draw the board on the screen using the pygame.draw.rect function

    draw_over(end_text='Game Over')
        Draw the game over screen
        Args:
            end_text: str -> text to display on the game over screen

    draw_pieces(board)
        Draw the pieces on the board
        Colors of the pieces are defined in the colors dictionary by numbers in it
        Text color inside is defined by the value of the piece + font scale is adjusted based on the length of the value
        Args:
            board: list -> values of the board

    draw_return_button()
        Draw the return to menu button on the game screen

    draw_timer(remaining_time)
        Display the remaining time on the game screen

    draw_undo_button()
        Draw the undo button on the game screen with the cooldown counter or with undo text
        Return:
            undo_rect: pygame.Rect -> rectangle of the undo button

    handle_game_events(game_type='classic')
        Check the game events and handle them correctly based on the game type
        Args:
            game_type: str -> type of the game (classic or timed)

    handle_key_press(key_press_event)
        Handle the key press events for the game
        Args:
            key_press_event: pygame.event -> key press event on which the function decides what to do next

    handle_mouse_button(mouse_button_event)
        Handle the mouse button events for the game
        Args:
            mouse_button_event: pygame.event -> key press event on which the function decides what to do next

    main()
        Run the main menu and the game loop based on the user's choice

    main_menu()
        Draw the main menu of the game with the start, timed mode, tutorial, and exit buttons

    move_board(board, move_direction, game_type='classic')
        Move the board in the given direction
        Args:
            board: list -> values of the board
            move_direction: str -> direction of the move
            game_type: str -> type of the game (classic or timed)

    move_down(board, global_score)
        Move the board down and merge the tiles + update the score
        Args:
            board: list -> values of the board
            global_score: int -> score of the game
        Return:
            board: list -> updated values of the board after move DOWN
            global_score: int -> updated score of the game

    move_left(board, global_score)
        Move the board left and merge the tiles + update the score
        Args:
            board: list -> values of the board
            global_score: int -> score of the game
        Return:
            board: list -> updated values of the board after move LEFT
            global_score: int -> updated score of the game

    move_right(board, global_score)
        Move the board right and merge the tiles + update the score
        Args:
            board: list -> values of the board
            global_score: int -> score of the game
        Return:
            board: list -> updated values of the board after move RIGHT
            global_score: int -> updated score of the game

    move_up(board, global_score)
        Move the board up and merge the tiles + update the score
        Args:
            board: list -> values of the board
            global_score: int -> score of the game
        Return:
            board: list -> updated values of the board after move UP
            global_score: int -> updated score of the game

    reset_game_data()
        Restart the game -> resets game values

    reset_timed_game_data()
        Restart the timed game -> resets game values + timed game values

    return_one_move()
        Return one move back in the game by popping the last state from the previous_states list
        Return:
            bool -> True if the move is undone, False otherwise
```
